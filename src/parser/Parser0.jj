PARSER_BEGIN(Parser0)

package parser;

import ast.*;import ast.integer.ASTAdd;import ast.integer.ASTDiv;import ast.integer.ASTSub;
import java.util.Map;
import java.util.HashMap;

public class Parser0 {

}

PARSER_END(Parser0)

SKIP :
{
	" "
	|
	"\t"
	|
	"\r"
	|
	"\n"
}

TOKEN :
{
	< NEW : "new" >
	|
	< IF : "if" >
	|
	< ELSE : "else" >
	|
	< WHILE : "while" >
	|
	< PRINTLN : "println" >
	|
	< TRUE : "true" >
	|
	< FALSE : "false" >
	|
	< NOT : "!" >
	|
	< EQ : "==" >
	|
	< GR : ">" >
	|
	< GREQ : ">=" >
	|
	< AND : "&&" >
	|
	< OR : "||" >
	|
	< LET : "let" >
	|
	< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] ) * >
	|
	< NUM: (["0"-"9"]) + >
	|
	< PLUS : "+" >
	|
	< MINUS : "-" >
	|
	< MULT : "*" >
	|
	< DIV : "/" >
	|
	< LPAR : "(" >
	|
	< RPAR : ")" >
	|
	< BIND : "=" >
	|
	< SEMI : ";" >
	|
	< LCBRA : "{" >
	|
	< RCBRA : "}" >
}

ASTNode Start() :
{
	ASTNode t;
}
{
	t = Bind() <SEMI><SEMI>
	{
		return t;
	}
}

ASTNode Bind() :
{
    ASTNode t1, t2;
}
{
	t1 = BoolAdd() ( <BIND> t2 = BoolAdd() <SEMI> ) *
	{
		return new ASTAssign(t1, t2);
	}
}

ASTNode BoolAdd() :
{
    ASTNode t1, t2;
}
{
	t1 = BoolMult() ( <OR> t2 = BoolMult() ) *
	{
		return new ASTOr(t1, t2);
	}
}

ASTNode BoolMult() :
{
    ASTNode t1, t2;
}
{
	t1 = RelOp() ( <AND> t2 = RelOp() ) *
	{
		return new ASTAnd(t1, t2);
	}
}

ASTNode RelOp() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Exp() ( ( op = <EQ> | op = <GREQ> | op = <GR> ) t2 = Exp()
	{
		switch (op.kind) {
			case EQ -> t1 = new ASTEq(t1, t2);
			case GREQ -> t1 = new ASTGrEq(t1, t2);
			case GR -> t1 = new ASTGr(t1, t2);
		}
	}
    ) ?
    {
		return t1;
	}
}

ASTNode Exp() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Term() ( ( op = <PLUS> | op = <MINUS> ) t2 = Term()
	{
		switch (op.kind) {
			case PLUS -> t1 = new ASTAdd(t1, t2);
			case MINUS -> t1 = new ASTSub(t1, t2);
		}
}
    ) *
    {
		return t1;
	}
}

ASTNode Term() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Fact() ( ( op = <MULT> | op = <DIV> ) t2 = Term()
    {
        switch (op.kind) {
       	    case TIMES -> t1 = new ASTMult(t1, t2);
       		case DIV -> t1 = new ASTDiv(t1, t2);
	   }
}
	) ?
	{
		return t1;
	}
}

ASTNode Fact() :
{
	Token n;
	ASTNode t;
}
{
	(
    n = <NUM>
	{
		t = new ASTNum(Integer.parseInt(n.image));
    }
	|
	n = <ID>
	{
		t = new ASTId(n.image);
	}
	|
	<TRUE>
	{
		t = new ASTNum(1);
	}
	|
	<FALSE>
	{
		t = new ASTNum(0);
	}
	|
	<LPAR> t = BoolAdd() <RPAR>
	|
	<MINUS>
	{
		t = new ASTNeg(Fact());
	}
	|
	<NOT>
	{
		t = new ASTNeg(Fact());
	}
	|
	<LCBRA> t = Scope() <RCBRA>
	)
	{
		return t;
	}
}

ASTNode Scope() :
{
    Token id;
	ASTNode val, body;
	Map<String, ASTNode> bindings = new HashMap<>();
}
{
	(
	<LET> id = <ID> <BIND> val = Exp() <SEMI>
	{
		bindings.put(id.image, val);
	}
	) *
	(
		body = Exp()
	) ?
	{
		return new ASTScope(bindings, body);
	}
}
