PARSER_BEGIN(Parser0)

package parser;

import ast.*;
import ast.integer.*;
import ast.bool.*;
import java.util.Map;
import java.util.HashMap;

public class Parser0 {

}

PARSER_END(Parser0)

SKIP :
{
	" "
	|
	"\t"
	|
	"\r"
	|
	"\n"
}

TOKEN :
{
	< DEREF : "~" >
	|
	< MUT : "mut" >
	|
	< IF : "if" >
	|
	< ELSE : "else" >
	|
	< WHILE : "while" >
	|
	< PRINTLN : "println" >
	|
	< TRUE : "true" >
	|
	< FALSE : "false" >
	|
	< NOT : "!" >
	|
	< EQ : "==" >
	|
	< GR : ">" >
	|
	< GREQ : ">=" >
	|
	< AND : "&&" >
	|
	< OR : "||" >
	|
	< LET : "let" >
	|
	< ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] ) * >
	|
	< NUM: (["0"-"9"]) + >
	|
	< PLUS : "+" >
	|
	< MINUS : "-" >
	|
	< MULT : "*" >
	|
	< DIV : "/" >
	|
	< LPAR : "(" >
	|
	< RPAR : ")" >
	|
	< BIND : "=" >
	|
	< SEMI : ";" >
	|
	< DSEMI : ";;" >
	|
	< LCBRA : "{" >
	|
	< RCBRA : "}" >
}

ASTNode Start() :
{
	ASTNode t;
}
{
	t = Bind()
	(
		<SEMI>
		{
			t = new ASTExpSeq(t, Bind());
		}
	) *
	( <DSEMI> ) ?
	{
		return t;
	}
}

ASTNode Bind() :
{
    ASTNode t1, t2;
}
{
	t1 = BoolAdd() ( <BIND> t2 = BoolAdd()
	{
		t1 = new ASTAssign(t1, t2);
	}
	) *
	{
		return t1;
	}
}

ASTNode BoolAdd() :
{
    ASTNode t1, t2;
}
{
	t1 = BoolMult() ( <OR> t2 = BoolMult()
	{
		t1 = new ASTOr(t1, t2);
	}
	) *
	{
    	return t1;
    }
}

ASTNode BoolMult() :
{
    ASTNode t1, t2;
}
{
	t1 = RelOp() ( <AND> t2 = RelOp()
	{
		t1 = new ASTAnd(t1, t2);
	}
	) *
	{
        return t1;
    }
}

ASTNode RelOp() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Exp() ( ( op = <EQ> | op = <GREQ> | op = <GR> ) t2 = Exp()
	{
			if (op.kind == EQ) t1 = new ASTEq(t1, t2);
			else if (op.kind == GREQ) t1 = new ASTGrEq(t1, t2);
			else if (op.kind == GR) t1 = new ASTGr(t1, t2);
	}
    ) ?
    {
		return t1;
	}
}

ASTNode Exp() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Term() ( ( op = <PLUS> | op = <MINUS> ) t2 = Term()
	{
		if (op.kind == PLUS) t1 = new ASTAdd(t1, t2);
		else if (op.kind == MINUS) t1 = new ASTSub(t1, t2);
	}
    ) *
    {
		return t1;
	}
}

ASTNode Term() :
{
	Token op;
	ASTNode t1, t2;
}
{
	t1 = Fact() ( ( op = <MULT> | op = <DIV> ) t2 = Term()
    {
       	if (op.kind == MULT) t1 = new ASTMult(t1, t2);
       	else if (op.kind == DIV) t1 = new ASTDiv(t1, t2);
	}
	) ?
	{
		return t1;
	}
}

ASTNode Fact() :
{
	Token n;
	ASTNode t;
}
{
	(
	<DEREF>
	{
		t = new ASTDeref(Fact());
	}
	|
	<TRUE>
	{
		t = new ASTBool(true);
	}
	|
	<FALSE>
	{
		t = new ASTBool(false);
	}
	|
	<PRINTLN>
	{
		t = new ASTPrintln(BoolAdd());
	}
	|
    n = <NUM>
	{
		t = new ASTNum(Integer.parseInt(n.image));
    }
	|
	n = <ID>
	{
		t = new ASTId(n.image);
	}
	|
	<LPAR> t = BoolAdd() <RPAR>
	|
	<MINUS>
	{
		t = new ASTNeg(Fact());
	}
	|
	<NOT>
	{
		t = new ASTNot(BoolAdd());
	}
	|
	<LCBRA> t = Scope() <RCBRA>
	|
	<WHILE> t = While()
	)
	{
		return t;
	}
}

ASTNode Scope() :
{
    Token id, m = null;
	ASTNode val, body = null;
	Map<String, ASTNode> bindings = new HashMap<>();
}
{
	(
	<LET> ( m = <MUT> ) ? id = <ID> <BIND> val = BoolAdd() <SEMI>
	{
		if (m != null)
			val = new ASTNew(val);
		bindings.put(id.image, val);
	}
	) *
	(
		body = Start()
	) +
	{
		return new ASTScope(bindings, body);
	}
}

ASTNode While() :
{
	ASTNode condition, body;
}
{
	condition = BoolAdd() <LCBRA> body = Start() <RCBRA>
	{
        return new ASTWhile(condition, body);
    }
}
